-- 1. Create PROFILES table
create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  bio text,
  banner_url text,

  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);
alter table public.profiles enable row level security;

-- 2. Create POSTS table
create table public.posts (
  id uuid not null default gen_random_uuid(),
  created_at timestamp with time zone not null default now(),
  content text not null,
  author_id uuid not null references public.profiles on delete cascade,
  image_url text,
  
  primary key (id)
);
alter table public.posts enable row level security;

-- 3. Create LIKES table
create table public.likes (
  id bigint generated by default as identity,
  user_id uuid not null references public.profiles on delete cascade,
  post_id uuid not null references public.posts on delete cascade,
  
  primary key (id),
  unique (user_id, post_id)
);
alter table public.likes enable row level security;

-- 4. Create COMMENTS table
create table public.comments (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  content text not null,
  author_id uuid not null references public.profiles on delete cascade,
  post_id uuid not null references public.posts on delete cascade,

  primary key (id)
);
alter table public.comments enable row level security;

-- 5. Create FOLLOWERS table
create table public.followers (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    follower_id uuid not null references public.profiles(id) on delete cascade,
    followed_id uuid not null references public.profiles(id) on delete cascade,

    primary key (id),
    unique(follower_id, followed_id)
);
alter table public.followers enable row level security;

-- 6. Create CHAT tables
create table public.conversations (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    
    primary key (id)
);
alter table public.conversations enable row level security;

create table public.conversation_participants (
    id bigint generated by default as identity,
    conversation_id bigint not null references public.conversations(id) on delete cascade,
    user_id uuid not null references public.profiles(id) on delete cascade,

    primary key (id),
    unique(conversation_id, user_id)
);
alter table public.conversation_participants enable row level security;

create table public.messages (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    content text not null,
    sender_id uuid not null references public.profiles(id) on delete cascade,
    conversation_id bigint not null references public.conversations(id) on delete cascade,

    primary key (id)
);
alter table public.messages enable row level security;


-- VIEWS
create or replace view public.posts_with_details as
select
  p.*,
  (select count(*)::int from likes where post_id = p.id) as likes_count,
  (select count(*)::int from comments where post_id = p.id) as comments_count,
  (select auth.uid() is not null and exists(select 1 from likes where post_id = p.id and user_id = auth.uid())) as user_has_liked_post,
  json_build_object(
    'id', pr.id,
    'username', pr.username,
    'full_name', pr.full_name,
    'avatar_url', pr.avatar_url
  ) as author
from posts p
join profiles pr on p.author_id = pr.id;


create or replace view public.comments_with_author as
select
  c.*,
  json_build_object(
    'id', pr.id,
    'username', pr.username,
    'full_name', pr.full_name,
    'avatar_url', pr.avatar_url
  ) as author
from comments c
join profiles pr on c.author_id = pr.id;

create or replace view public.profiles_with_follow_counts as
select
    p.*,
    (select count(*) from followers where followed_id = p.id) as followers_count,
    (select count(*) from followers where follower_id = p.id) as following_count
from
    profiles p;

-- RLS POLICIES
-- Policies for PROFILES table
create policy "Public profiles are viewable by everyone."
  on profiles for select using (true);
create policy "Users can insert their own profile."
  on profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile."
  on profiles for update using (auth.uid() = id) with check (auth.uid() = id);

-- Policies for POSTS table
create policy "Posts are viewable by everyone."
  on posts for select using (true);
create policy "Users can create their own posts."
  on posts for insert with check (auth.uid() = author_id);
create policy "Users can update their own posts."
  on posts for update using (auth.uid() = author_id) with check (auth.uid() = author_id);
create policy "Users can delete their own posts."
  on posts for delete using (auth.uid() = author_id);

-- Policies for LIKES table
create policy "Users can view all likes."
  on likes for select using (true);
create policy "Users can like posts."
  on likes for insert with check (auth.uid() = user_id);
create policy "Users can unlike their own likes."
  on likes for delete using (auth.uid() = user_id);

-- Policies for COMMENTS table
create policy "Users can view all comments."
  on comments for select using (true);
create policy "Users can create their own comments."
  on comments for insert with check (auth.uid() = author_id);
create policy "Users can delete their own comments."
  on comments for delete using (auth.uid() = author_id);

-- Policies for FOLLOWERS table
create policy "Users can view all follower relationships."
  on followers for select using (true);
create policy "Users can follow other users."
  on followers for insert with check (auth.uid() = follower_id);
create policy "Users can unfollow users they follow."
  on followers for delete using (auth.uid() = follower_id);
  
-- Policies for CHAT tables
create policy "Users can view conversations they are a part of."
    on conversations for select using (
        exists (
            select 1 from conversation_participants cp
            where cp.conversation_id = id and cp.user_id = auth.uid()
        )
    );

create policy "Users can create conversations."
    on conversations for insert with check (true);

create policy "Users can view participants of their conversations."
    on conversation_participants for select using (
        exists (
            select 1 from conversation_participants cp
            where cp.conversation_id = conversation_participants.conversation_id and cp.user_id = auth.uid()
        )
    );
    
create policy "Users can add participants to conversations."
    on conversation_participants for insert with check (
        exists (
            select 1 from conversation_participants cp
            where cp.conversation_id = conversation_participants.conversation_id and cp.user_id = auth.uid()
        )
    );

create policy "Users can view messages in their conversations."
    on messages for select using (
        exists (
            select 1 from conversation_participants cp
            where cp.conversation_id = messages.conversation_id and cp.user_id = auth.uid()
        )
    );

create policy "Users can send messages in their conversations."
    on messages for insert with check (
        sender_id = auth.uid() and
        exists (
            select 1 from conversation_participants cp
            where cp.conversation_id = messages.conversation_id and cp.user_id = auth.uid()
        )
    );


-- TRIGGERS
-- This trigger automatically creates a profile entry for new users.
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, username, full_name, avatar_url)
  values (
      new.id,
      new.raw_user_meta_data ->> 'user_name',
      new.raw_user_meta_data ->> 'full_name',
      new.raw_user_meta_data ->> 'avatar_url'
  );
  return new;
end;
$$ language plpgsql security definer;

-- Drop existing trigger if it exists, to avoid errors on re-run
drop trigger if exists on_auth_user_created on auth.users;

-- Create the trigger
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- STORAGE POLICIES
-- Policies for AVATARS bucket
create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );

create policy "Anyone can update their own avatar."
  on storage.objects for update
  using ( auth.uid() = owner )
  with check ( bucket_id = 'avatars' );
  
create policy "Anyone can delete their own avatar."
  on storage.objects for delete
  using ( auth.uid() = owner )
  with check ( bucket_id = 'avatars' );

-- Policies for BANNERS bucket
create policy "Banner images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'banners' );

create policy "Anyone can upload a banner."
  on storage.objects for insert
  with check ( bucket_id = 'banners' );

create policy "Anyone can update their own banner."
  on storage.objects for update
  using ( auth.uid() = owner )
  with check ( bucket_id = 'banners' );

create policy "Anyone can delete their own banner."
  on storage.objects for delete
  using ( auth.uid() = owner )
  with check ( bucket_id = 'banners' );
